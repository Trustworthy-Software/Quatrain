Lang-1$$NumberUtils does not handle Long Hex numbers$$NumberUtils.createLong() does not handle hex numbers, but createInteger() handles hex and octal. This seems odd. NumberUtils.createNumber() assumes that hex numbers can only be Integer. Again, why not handle bigger Hex numbers? == It is trivial to fix createLong() - just use Long.decode() instead of valueOf(). It's not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2. Fixing createNumber() is also fairly easy - if the hex string has more than 8 digits, use Long. Should we allow for leading zeros in an Integer?  If not, the length check is trivial.
Lang-3$$Method createNumber from NumberUtils doesn't work for floating point numbers other than Float$$Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.
Lang-4$$LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String$$The core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence, CharSequence> lookupMap. From the Javadoc of CharSequence (emphasis mine):  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map. The current implementation causes code such as the following to not work as expected:  CharSequence cs1 = "1 < 2"; CharSequence cs2 = CharBuffer.wrap("1 < 2".toCharArray());  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1)); System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));   ... which gives the following results (but should be identical):  1 &lt; 2 1 < 2   The problem, at a minimum, is that CharBuffer.equals is even documented in the Javadoc that:  A char buffer is not equal to any other type of object. ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains. An obvious work-around is to instead use something along the lines of either of the following:  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString())); System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));   ... which forces everything back to a String.  However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns.  (As such, I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.) Another option that I'm considering is to use a custom CharSequence wrapper around a char[] that implements hashCode() and equals() to work with those implemented on String.  (However, this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)
Lang-5$$LocaleUtils.toLocale does not parse strings starting with an underscore$$Hi, Javadocs of Locale.toString() states that "If the language is missing, the string will begin with an underbar.". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString(). The fix for the ticket 328 does not handle well the case "fr__P", which I found out during fixing the first bug. I am attaching the patch for both problems.
Lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException
Lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.
Lang-8$$FastDateFormat's "z" pattern does not respect timezone of Calendar instances passed to format()$$The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3. The problem can be seen by this snippet:  // Always prints timezone name of machine's default timezone, ignoring TZ // set on calendar, even though the printed time itself respects calendar's TZ. Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone("US/Central")); System.out.println(FastDateFormat.getInstance("h:mma z").format(myCal));   If you happen to be in US/Central, this will print the right thing, but just try it with US/Eastern, US/Pacific, etc.  It will print the time in the correct timezone, but the timezone name at the end (the "z" pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x. Basically, when the "forced time zone" code was removed, the TimeZoneNameRule class stopped respecting the Calendar instance's timezone, and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long). The removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance, but rather to use the TimeZone on the Calendar instance passed into appendTo(), just like TimeZoneNumberRule does.  Presumably then for efficiency, one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezone's display name.
Lang-9$$FastDateParser does not handle unterminated quotes correctly$$FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: 'd'd' Date: d3 This should fail to parse the format and date but it actually works. The format is parsed as: Pattern: d(\p {IsNd} ++)
Lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.
Lang-11$$RandomStringUtils throws confusing IAE when end <= start$$RandomUtils invokes Random#nextInt where n = end - start. If end <= start, then Random throws: java.lang.IllegalArgumentException: n must be positive This is confusing, and does not identify the source of the problem.
Lang-12$$RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException$$In commons-lang 2.6 line 250 :  ch = chars[random.nextInt(gap) + start];  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = chars[random.nextInt(gap)%chars.length];  When user pass 0 as end or when the array is not null but empty this line ends up with an exception
Lang-13$$SerializationUtils throws ClassNotFoundException when cloning primitive classes$$If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest {  	 	@Test 	public void primitiveTypeClassSerialization(){ 		Class<?> primitiveType = int.class; 		 		Class<?> clone = SerializationUtils.clone(primitiveType); 		assertEquals(primitiveType, clone); 	} }   The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {             	try {             	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             	} catch (Exception e) { 		     return super.resolveClass(desc); 		}             }         }   Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) 	throws IOException, ClassNotFoundException     { 	String name = desc.getName(); 	try { 	    return Class.forName(name, false, latestUserDefinedLoader()); 	} catch (ClassNotFoundException ex) { 	    Class cl = (Class) primClasses.get(name); 	    if (cl != null) { 		return cl; 	    } else { 		throw ex; 	    } 	}     }
Lang-14$$StringUtils equals() relies on undefined behavior$$Since the java.lang.CharSequence class was first introduced in 1.4, the JavaDoc block has contained the following note:  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. When the signature of the StringUtils equals() method was changed from equals(String, String) to equals(CharSequence, CharSequence) in R920543, the implementation still relied on calling CharSequence#equals(Object) even though, in general, the result is undefined. One example where equals(Object) returns false even though, as CharSequences, two objects represent equal sequences is when one object is an instance of javax.lang.model.element.Name and the other object is a String.
Lang-15$$TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes$$failing test code to add to TypeUtilsTest.testGetTypeArguments():  typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));   These should pass based on:   public interface This<K, V> { }  public class Other<T> implements This<String, T> { }   This case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.
Lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.
Lang-17$$StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.$$Hello. I use StringEscapeUtils.escapeXml(input) to escape special characters for XML. This method outputs wrong results when input contains characters in Supplementary Planes. String str1 = "\uD842\uDFB7" + "A"; String str2 = StringEscapeUtils.escapeXml(str1); // The value of str2 must be equal to the one of str1, // because str1 does not contain characters to be escaped. // However, str2 is diffrent from str1. System.out.println(URLEncoder.encode(str1, "UTF-16BE")); //%D8%42%DF%B7A System.out.println(URLEncoder.encode(str2, "UTF-16BE")); //%D8%42%DF%B7%FF%FD The cause of this problem is that the loop to translate input character by character is wrong. In CharSequenceTranslator.translate(CharSequence input, Writer out), loop counter "i" moves from 0 to Character.codePointCount(input, 0, input.length()), but it should move from 0 to input.length().
Lang-18$$FastDateFormat formats year differently than SimpleDateFormat in Java 7$$Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.
Lang-19$$StringIndexOutOfBoundsException when calling unescapeHtml4("&#03")$$When calling unescapeHtml4() on the String "&#03" (or any String that contains these characters) an Exception is thrown: Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 4 	at java.lang.String.charAt(String.java:686) 	at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) 	at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) 	at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)
Lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress
Lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)
Lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());
Lang-23$$text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object)$$Findbugs: Bug: org.apache.commons.lang3.text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object) Pattern id: EQ_DOESNT_OVERRIDE_EQUALS, type: Eq, category: STYLE This class extends a class that defines an equals method and adds fields, but doesn't define an equals method itself. Thus, equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended, and that you don't need to override the equals method. Even if you don't need to override the equals method, consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o).
Lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }
Lang-25$$Some Entitys like &Ouml; are not matched properly against its ISO8859-1 representation$$In EntityArrays  In  private static final String[][] ISO8859_1_ESCAPE  some matching is wrong, for example            {"\u00D7", "&Ouml;"}, // Ö - uppercase O, umlaut         {"\u00D8", "&times;"}, // multiplication sign   but this must be              {"\u00D6", "&Ouml;"}, // Ö - uppercase O, umlaut         {"\u00D7", "&times;"}, // multiplication sign   according to http://www.fileformat.info/info/unicode/block/latin_supplement/list.htm First look: u00CA is missing in the array and all following entries are matched wrong by an offset of 1. Found on http://stackoverflow.com/questions/4172784/bug-in-apache-commons-stringescapeutil/4172915#4172915
Lang-26$$FastDateFormat.format() outputs incorrect week of year because locale isn't respected$$FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo {     public static void main(String[] args) {         Locale.setDefault(new Locale("en", "US"));         Locale locale = new Locale("sv", "SE");          Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome         cal.set(2010, 0, 1, 12, 0, 0);         Date d = cal.getTime();         System.out.println("Target date: " + d);          FastDateFormat fdf = FastDateFormat.getInstance("EEEE', week 'ww", locale);         SimpleDateFormat sdf = new SimpleDateFormat("EEEE', week 'ww", locale);         System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"         System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"     } }   If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.
Lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".
Lang-28$$StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters$$Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer, String str) throws IOException {         int len = str.length();         for (int i = 0; i < len; i++) {             int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)  {                 writer.write('&');                 writer.write(entityName);                 writer.write(';');             }  else if (code > 0x7F)  {                     writer.write("&#");                     writer.write(code);                     writer.write(';');             }  else  {                     writer.write((char) code);             }              if (code > 0xffff)  {                     i++;             }         }     } Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().
Lang-29$$SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM$$Can be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): 	... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): 	... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): 	at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)
Lang-30$$StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.$$StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00" 	private static final String CharU20000 = "\uD840\uDC00"; 	private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call: 	assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken: 	assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001)); 	assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine: 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000)); 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001)); 	assertEquals(true, StringUtils.contains(CharU20000, CharU20000)); 	assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/
Lang-31$$StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.$$StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00" 	private static final String CharU20000 = "\uD840\uDC00"; 	private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call: 	assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken: 	assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001)); 	assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine: 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000)); 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001)); 	assertEquals(true, StringUtils.contains(CharU20000, CharU20000)); 	assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/
Lang-32$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.
Lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary
Lang-34$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.
Lang-35$$ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException$$ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.
Lang-36$$NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place$$NumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., "2." should be considered a number because new BigDecimal("2.") works fine.  This could be done by adding the code below after line 1444, which is the if (chars[i] == 'e' || chars[i] == 'E') block. if (chars[i] == '.') {     if (hasDecPoint || hasExp)  {         // two decimal points or dec in exponent            return false;     }     return foundDigit; // single trailing decimal point after non-exponent is ok }
Lang-37$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well. The stack trace for  Number[] st = ArrayUtils.addAll(new Integer[] {1} , new Long[] {2L} ); starts: java.lang.ArrayStoreException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.
Lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }
Lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }
Lang-40$$Fix case-insensitive string handling$$String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.
Lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));
Lang-42$$StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters$$Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely: import org.apache.commons.lang.*; public class J2 {     public static void main(String[] args) throws Exception {         // this is the utf8 representation of the character:         // COUNTING ROD UNIT DIGIT THREE         // in unicode         // codepoint: U+1D362         byte[] data = new byte[]  { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 } ;         //output is: &#55348;&#57186;         // should be: &#119650;         System.out.println("'" + StringEscapeUtils.escapeHtml(new String(data, "UTF8")) + "'");     } } Should be very quick to fix, feel free to drop me an email if you want a patch.
Lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }
Lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.
Lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string
Lang-46$$StringEscapeUtils.escapeJava(String) escapes '/' characters$$Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid "escapable" character in Java strings.  I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java "escapable" characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase {     public void testEscapeJavaWithSlash()  {         final String input = "String with a slash (/) in it";                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,          * which are not a valid character to escape in a Java string.            */         assertEquals( expected, actual );     } }
Lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.
Lang-48$$EqualsBuilder don't compare BigDecimals correctly$$When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.
Lang-49$$infinite loop in Fraction.reduce when numerator == 0$$Summary pretty much says it all.
Lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.
Lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.
Lang-52$$StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\/', it will make IE render page uncorrectly$$If Javascripts including'/', IE will parse the scripts uncorrectly, actually '/' should be escaped to '\/'. For example, document.getElementById("test").value = '<script>alert(\'aaa\');</script>';this expression will make IE render page uncorrect, it should be document.getElementById("test").value = '<script>alert(\'aaa\');<\/script>'; Btw, Spring's JavascriptEscape behavor is correct. Try  to run below codes, you will find the difference:   String s = "<script>alert('aaa');</script>";   String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);   System.out.println("Spring JS Escape : "+str);   str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);   System.out.println("Apache Common Lang JS Escape : "+ str);
Lang-53$$Dates.round() behaves incorrectly for minutes and seconds$$Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong
Lang-54$$LocaleUtils.toLocale() rejects strings with only language+variant$$LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.
Lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?
Lang-56$$FastDateFormat.mRules is not transient or serializable$$Reported by FindBugs. Either we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().
Lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.
Lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"
Lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.
Lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.
Lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult$1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult$1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Lang-62$$unescapeXml("&12345678;") should be "&12345678;"$$Following test (in EntitiesTest.java) fails:     public void testNumberOverflow() throws Exception  {         doTestUnescapeEntity("&#12345678;", "&#12345678;");         doTestUnescapeEntity("x&#12345678;y", "x&#12345678;y");         doTestUnescapeEntity("&#x12345678;", "&#x12345678;");         doTestUnescapeEntity("x&#x12345678;y", "x&#x12345678;y");     }  Maximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.
Lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);
Lang-64$$ValuedEnum.compareTo(Object other) not typesafe - it easily could be...$$int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum
Lang-65$$[lang] DateUtils.truncate method is buggy when dealing with DST switching hours$$Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10- 31 01:00:00 MST, which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT, result);
